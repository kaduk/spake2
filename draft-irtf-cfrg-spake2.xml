<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4493 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4493.xml">
<!ENTITY RFC5480 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5480.xml">
<!ENTITY RFC5869 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5869.xml">
<!ENTITY RFC6234 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6234.xml">
<!ENTITY RFC7748 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7748.xml">
<!ENTITY RFC8032 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8032.xml">
<!ENTITY RFC8174 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY RFC8265 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8265.xml">
]>
<?rfc toc="yes"?>
<?rfc tocdepth="1"?>
<rfc category="info" ipr="trust200902" docName="draft-irtf-cfrg-spake2-07" submissionType="IETF">
  <front>
    <title>SPAKE2, a PAKE</title>
    <author fullname="Watson Ladd" initials="W." surname="Ladd">
      <organization>UC Berkeley</organization>
      <address>
        <email>watsonbladd@gmail.com</email>
      </address>
    </author>
    <author role="editor" initials="B." surname="Kaduk" fullname="Benjamin Kaduk">
      <organization abbrev="Akamai">Akamai Technologies</organization>
      <address>
        <email>kaduk@mit.edu</email>
      </address>
    </author>
    <date month="November" year="2018"/>
    <abstract>
      <t>This document describes SPAKE2, a means for two parties that share a password
        to derive a strong shared key with no risk of disclosing the password.
        This method is compatible with any group, is
        computationally efficient, and has a security proof.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" title="Introduction">
      <t>This document describes SPAKE2, a means for two parties that share a password
        to derive a strong shared key with no risk of disclosing the password.
        This password-based key exchange protocol is compatible with any group
        (requiring only a scheme to map a random input of fixed length per group
        to a random group element), is
        computationally efficient, and has a security proof.
        Predetermined parameters for a selection of commonly used groups are
        also provided for use by other protocols.</t>
    </section>
    <section anchor="notation" title="Requirements Notation">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119" /> <xref target="RFC8174" />
        when, and only when, they
        appear in all capitals, as shown here.</t>
    </section>
    <section anchor="definition" title="Definition of SPAKE2">
      <section title="Setup">
        <t>Let G be a group in which the computational Diffie-Hellman (CDH)
          problem is hard. Suppose G has order p*h where p is a large prime;
          h will be called the cofactor. We denote the
          operations in the group additively. We assume there is a representation of
          elements of G as byte strings: common choices would be SEC1
          compressed <xref target="SEC1" /> for elliptic curve groups or big
          endian integers of a fixed (per-group) length for prime field DH.</t>

        <t>|| denotes concatenation of strings. We also let len(S) denote the
          length of a string in bytes, represented as an eight-byte little-
          endian number. Finally, let nil represent an empty string, i.e.,
          len(nil) = 0.</t>

        <t>KDF is a key-derivation function that takes as input a salt, intermediate
          keying material (IKM), info string, and derived key length L to derive a
          cryptographic key of length L. MAC is a Message
          Authentication Code algorithm that takes a secret key and
          message as input to produce an output. Let Hash be a hash function from
          arbitrary strings to bit strings of a fixed length. Common choices
          for H are SHA256 or SHA512 <xref target="RFC6234"/>. MHF is a memory-hard
          hash function designed to slow down brute-force attackers. Scrypt <xref target="RFC7914"/>
          is a common example of this function. The output length of MHF matches that
          of Hash. Parameter selection for MHF is out of scope for this document.
          <xref target="Ciphersuites"/> specifies variants of KDF, MAC, Hash, and MHF
          suitable for use with the protocols contained herein.</t>

        <t>We fix two elements M and N as defined in the table in this document
          for common groups, as well as a generator P of the group. P is
          specified in the document defining the group, and so we do not repeat
          it here.</t>

        <t>Let A and B be two parties. A and B may also have digital
          representations of the parties' identities such as Media Access Control addresses
          or other names (hostnames, usernames, etc). A and B may share Additional
          Authenticated Data (AAD) of length at most 2^16 - 1 bits that is separate
          from their identities which they may want to include in the protocol execution.
          We assume they share an integer w;
          typically w = MHF(pw) mod p, for a user-supplied password pw.
          Standards such NIST.SP.800-56Ar3 suggest taking mod p of a
          hash value that is 64 bits longer than that needed to represent p to remove
          statistical bias introduced by the modulation. Protocols using this specification must define
          the method used to compute w: it may be necessary to carry out various
          forms of normalization of the password before hashing <xref target="RFC8265" />.
          The hashing algorithm SHOULD be a MHF so as to slow down brute-force
          attackers. </t>

        <t>We present two protocols below. Note that it is insecure to use the
          same password with both protocols; passwords MUST NOT be used for
          both SPAKE2 and SPAKE2+.</t>
      </section>
      <section title="SPAKE2" anchor="spake2">
        <t>To begin, A picks x randomly and uniformly from the integers in [0,p*h)
            divisible by h, and calculates X=x*P and T=w*M+X, then transmits T to
            B.</t>

        <t>B selects y randomly and uniformly from the integers in [0,p*h),
          divisible by h and calculates Y=y*P, S=w*N+Y, then transmits S to A.</t>

        <t>Both A and B calculate a group element K. A calculates it as
          h*x(S-wN), while B calculates it as h*y(T-w*M). A knows S because it has
          received it, and likewise B knows T. A and B multiply protocol messages from
          each peer by h so as to avoid small subgroup attacks.</t>

        <t>K is a shared value, though it MUST NOT be used as a shared secret.
          Both A and B must derive two shared secrets from K and the protocol transcript.
          This prevents man-in-the-middle attackers from inserting themselves into
          the exchange. The transcript T is encoded as follows:</t>

        <figure><artwork><![CDATA[
            T = len(A) || A || len(B) || B || len(S) || S || len(T) || T
             || len(K) || K || len(w) || w
        ]]></artwork></figure>

        <t>If an identity is absent, it is omitted from the transcript entirely. For example,
          if both A and B are absent, then T = len(S) || S || len(T) || T || len(K) || K || len(w) || w.
          Likewise, if only A is absent, T = len(B) || B || len(S) || S || len(T) || T || len(K) || K || len(w) || w.
          This must only be done for applications in which identities are implicit. Otherwise,
          the protocol risks Unknown Key Share attacks.</t>

        <t>Upon completion of this protocol, A and B compute shared secrets Ke, KcA, and KcB as
            specified in <xref target="keys"/>. A MUST send B a key confirmation message
            so both parties agree upon these shared secrets. This confirmation message F
            is computed as a MAC over the protocol transcript T using KcA, as follows:
            F = MAC(KcA, T). Similarly, B MUST send A a confirmation message using a MAC
            computed equivalently except with the use of KcB. Key confirmation verification
            requires computing F and checking for equality against that which was received.</t>
      </section>

      <section title="SPAKE2+" anchor="spake2plus">
        <t>This protocol appears in <xref target="TDH" />. We
          use the same setup as for SPAKE2, except that we have two secrets, w0
          and w1, derived by hashing the password pw with the identities of the two
          participants, A and B. Specifically,
          w0s || w1s = MHF(len(pw) || pw || len(A) || A || len(B) || B),
          and then computing w0 = h*(w0s mod p) and w1 = h*(w1s mod p)
          to ensure both belong to the prime-order subgroup. B stores L=h*w1*P and w0.</t>

        <t>When executing SPAKE2+, A selects x uniformly at random from the
          numbers in the range [0, p*h) divisible by h, and lets X=x*P+w0*M, then
          transmits X to B. B selects y uniformly at random from the numbers in
          [0, p*h) divisible by h, then computes Y=y*P+w0*N, and transmits Y to A.</t>

        <t>A computes Z as h*x*(Y-w0*N), and V as h*w1*(Y-w0*N). B computes Z as h*y*(X-
          w0*M) and V as y*L. Both share Z and V as common keys. It is essential
          that both Z and V be used in combination with the transcript to
          derive the keying material. The protocol transcript encoding is shown below.</t>

        <figure><artwork><![CDATA[
            T = len(A) || A || len(B) || B || len(X) || X || len(Y) || Y
             || len(Z) || Z || len(V) || V || len(w0) || w0
        ]]></artwork></figure>

        <t>As in <xref target="spake2"/>, inclusion of A and B in the transcript is optional depending
        on whether or not the identities are implicit.</t>

        <t>Upon completion of this protocol, A and B follow the same key derivation and confirmation
            steps as outlined in <xref target="spake2"/>.</t>
      </section>
    </section>
    <section title="Key Schedule and Key Confirmation" anchor="keys">
        <t>The protocol transcript T, as defined in Sections <xref target="spake2plus"/> and
            <xref target="spake2"/>, is unique and secret to A and B. Both parties use T to
            derive shared symmetric secrets Ke and Ka as Ke || Ka = Hash(T). The length of each
            key is equal to half of the digest output, e.g., |Ke| = |Ka| = 128 bits for SHA-256.</t>

        <t>Both endpoints use Ka to derive subsequent MAC keys for key confirmation messages.
            Specifically, let KcA and KcB be the MAC keys used by A and B, respectively.
            A and B compute them as KcA || KcB = KDF(nil, Ka, "ConfirmationKeys" || AAD), where AAD
            is the associated data each given to each endpoint, or nil if none was provided.</t>

        <t>The resulting key schedule for this protocol, given transcript T and additional associated
            data AAD, is as follows.</t>

        <figure><artwork><![CDATA[
        T   -> Hash(T) = Ke || Ka
        AAD -> KDF(nil, Ka, "ConfirmationKeys" || AAD) = KcA || KcB
        ]]></artwork></figure>

        <t>A and B output Ke as the shared secret from the protocol. Ka and its derived keys are not
            used for anything except key confirmation.</t>
    </section>
    <section title="Ciphersuites" anchor="Ciphersuites">
        <t>
            This section documents SPAKE2 and SPAKE2+ ciphersuite configurations. A ciphersuite
            indicates a group, cryptographic hash algorithm, and pair of KDF and MAC functions, e.g.,
            SPAKE2-P256-SHA256-HKDF-HMAC. This ciphersuite indicates a SPAKE2 protocol instance over
            P-256 that uses SHA256 along with HKDF <xref target="RFC5869"/> and HMAC <xref target="RFC2104"/>
            for G, Hash, KDF, and MAC functions, respectively. Use of </t>

            <texttable anchor="spake2_ciphersuites" title="SPAKE2(+) Ciphersuites">
                <ttcol align='center'>G</ttcol>
                <ttcol align='center'>Hash</ttcol>
                <ttcol align='center'>KDF</ttcol>
                <ttcol align='center'>MAC</ttcol>
                <ttcol align='center'>MHF</ttcol>

                <!-- P256-SHA256-HKDF-HMAC -->
                <c>P-256</c>
                <c>SHA256 <xref target="RFC6234"/></c>
                <c>HKDF <xref target="RFC5869"/></c>
                <c>HMAC <xref target="RFC2104"/></c>
                <c>scrypt <xref target="RFC7914"/></c>

                <!-- P256-SHA512-HKDF-HMAC -->
                <c>P-256</c>
                <c>SHA512 <xref target="RFC6234"/></c>
                <c>HKDF <xref target="RFC5869"/></c>
                <c>HMAC <xref target="RFC2104"/></c>
                <c>scrypt <xref target="RFC7914"/></c>

                <!-- P384-SHA256-HKDF-HMAC -->
                <c>P-384</c>
                <c>SHA256 <xref target="RFC6234"/></c>
                <c>HKDF <xref target="RFC5869"/></c>
                <c>HMAC <xref target="RFC2104"/></c>
                <c>scrypt <xref target="RFC7914"/></c>

                <!-- P384-SHA512-HKDF-HMAC -->
                <c>P-384</c>
                <c>SHA512 <xref target="RFC6234"/></c>
                <c>HKDF <xref target="RFC5869"/></c>
                <c>HMAC <xref target="RFC2104"/></c>
                <c>scrypt <xref target="RFC7914"/></c>

                <!-- P512-SHA256-HKDF-HMAC -->
                <c>P-512</c>
                <c>SHA256 <xref target="RFC6234"/></c>
                <c>HKDF <xref target="RFC5869"/></c>
                <c>HMAC <xref target="RFC2104"/></c>
                <c>scrypt <xref target="RFC7914"/></c>

                <!-- P512-SHA512-HKDF-HMAC -->
                <c>P-512</c>
                <c>SHA512 <xref target="RFC6234"/></c>
                <c>HKDF <xref target="RFC5869"/></c>
                <c>HMAC <xref target="RFC2104"/></c>
                <c>scrypt <xref target="RFC7914"/></c>

                <!-- edwards25519-SHA512-HKDF-HMAC -->
                <c>edwards25519 <xref target="RFC7748"/></c>
                <c>SHA512 <xref target="RFC6234"/></c>
                <c>HKDF <xref target="RFC5869"/></c>
                <c>HMAC <xref target="RFC2104"/></c>
                <c>scrypt <xref target="RFC7914"/></c>

                <!-- edwards448-SHA512-HKDF-HMAC -->
                <c>edwards448 <xref target="RFC7748"/></c>
                <c>SHA512 <xref target="RFC6234"/></c>
                <c>HKDF <xref target="RFC5869"/></c>
                <c>HMAC <xref target="RFC2104"/></c>
                <c>scrypt <xref target="RFC7914"/></c>

                <!-- P256-SHA256-HKDF-CMAC -->
                <c>P-256</c>
                <c>SHA256 <xref target="RFC6234"/></c>
                <c>HKDF <xref target="RFC5869"/></c>
                <c>CMAC-AES-128 <xref target="RFC4493"/></c>
                <c>scrypt <xref target="RFC7914"/></c>

                <!-- P256-SHA512-HKDF-CMAC -->
                <c>P-256</c>
                <c>SHA512 <xref target="RFC6234"/></c>
                <c>HKDF <xref target="RFC5869"/></c>
                <c>CMAC-AES-128 <xref target="RFC4493"/></c>
                <c>scrypt <xref target="RFC7914"/></c>
            </texttable>

        <t>The following points represent permissible point generation seeds
            for the groups listed in the Table <xref target="spake2_ciphersuites"/>.
            These bytestrings are compressed points as in <xref target="SEC1" />
            for curves from <xref target="SEC1" />.</t>

      <t>For P256:</t>

      <figure><artwork><![CDATA[
M =
02886e2f97ace46e55ba9dd7242579f2993b64e16ef3dcab95afd497333d8fa12f
seed: 1.2.840.10045.3.1.7 point generation seed (M)

N =
03d8bbd6c639c62937b04d997f38c3770719c629d7014d49a24b4f98baa1292b49
seed: 1.2.840.10045.3.1.7 point generation seed (N)
]]></artwork></figure>

      <t>For P384:</t>

      <figure><artwork><![CDATA[
M =
030ff0895ae5ebf6187080a82d82b42e2765e3b2f8749c7e05eba366434b363d3dc
36f15314739074d2eb8613fceec2853
seed: 1.3.132.0.34 point generation seed (M)

N =
02c72cf2e390853a1c1c4ad816a62fd15824f56078918f43f922ca21518f9c543bb
252c5490214cf9aa3f0baab4b665c10
seed: 1.3.132.0.34 point generation seed (N)
]]></artwork></figure>

      <t>For P521:</t>

      <figure><artwork><![CDATA[
M =
02003f06f38131b2ba2600791e82488e8d20ab889af753a41806c5db18d37d85608
cfae06b82e4a72cd744c719193562a653ea1f119eef9356907edc9b56979962d7aa
seed: 1.3.132.0.35 point generation seed (M)

N =
0200c7924b9ec017f3094562894336a53c50167ba8c5963876880542bc669e494b25
32d76c5b53dfb349fdf69154b9e0048c58a42e8ed04cef052a3bc349d95575cd25
seed: 1.3.132.0.35 point generation seed (N)
]]></artwork></figure>

      <t>For edwards25519:</t>
      <figure><artwork><![CDATA[
M =
d048032c6ea0b6d697ddc2e86bda85a33adac920f1bf18e1b0c6d166a5cecdaf
seed: edwards25519 point generation seed (M)

N =
d3bfb518f44f3430f29d0c92af503865a1ed3281dc69b35dd868ba85f886c4ab
seed: edwards25519 point generation seed (N)
]]></artwork></figure>

      <t>For edwards448:</t>
      <figure><artwork><![CDATA[
M =
b6221038a775ecd007a4e4dde39fd76ae91d3cf0cc92be8f0c2fa6d6b66f9a12
942f5a92646109152292464f3e63d354701c7848d9fc3b8880
seed: edwards448 point generation seed (M)

N =
6034c65b66e4cd7a49b0edec3e3c9ccc4588afd8cf324e29f0a84a072531c4db
f97ff9af195ed714a689251f08f8e06e2d1f24a0ffc0146600
seed: edwards448 point generation seed (N)
]]></artwork></figure>

      <t>The following python snippet generates the above points,
      assuming an elliptic curve implementation following the
      interface of Edwards25519Point.stdbase() and
      Edwards448Point.stdbase() in <xref target="RFC8032"/> appendix A:</t>

      <figure><artwork><![CDATA[
def iterated_hash(seed, n):
    h = seed
    for i in range(n):
        h = hashlib.sha256(h).digest()
    return h

def bighash(seed, start, sz):
    n = -(-sz // 32)
    hashes = [iterated_hash(seed, i) for i in range(start, start + n)]
    return b''.join(hashes)[:sz]

def canon_pointstr(ecname, s):
    if ecname == 'edwards25519':
        return s
    elif ecname == 'edwards448':
        return s[:-1] + bytes([s[-1] & 0x80])
    else:
        return bytes([(s[0] & 1) | 2]) + s[1:]

def gen_point(seed, ecname, ec):
    for i in range(1, 1000):
        hval = bighash(seed, i, len(ec.encode()))
        pointstr = canon_pointstr(ecname, hval)
        try:
            p = ec.decode(pointstr)
            if p != ec.zero_elem() and p * p.l() == ec.zero_elem():
                return pointstr, i
        except Exception:
            pass
]]></artwork></figure>
    </section>
    <section title="Security Considerations">
      <t>A security proof of SPAKE2 for prime order groups is found in <xref
          target="REF" />.  Note that the choice of M and N is critical for the
        security proof.  The generation method specified in this document is
        designed to eliminate concerns related to knowing discrete logs of M
        and N.</t>

      <t>SPAKE2+ appears in <xref target="TDH" /> along with a path to a proof that
        server compromise does not lead to password compromise under the DH assumption
        (though the corresponding model excludes precomputation attacks).</t>

      <t>Elements received from a peer MUST be checked for group membership:
        failure to properly validate group elements can lead to attacks. In particular,
        it is essential that endpoints verify received points are valid compressions of
        points on an elliptic curve when using elliptic curves with point compression.
        It is not necessary to validate membership in the prime order subgroup: the
        implicit multiplication by cofactors when generating x and y eliminates
        the potential for membership of X and Y in a small-order subgroup.</t>

      <t>The choices of random numbers MUST BE uniform. Note that to pick a
        random multiple of h in [0, p*h) one can pick a random integer in [0, p)
        and multiply by h. Randomly generated values MUST NOT be reused; such reuse
        may permit dictionary attacks on the password.</t>

      <t>SPAKE2 does not support augmentation. As a result, the server has to
        store a password equivalent. This is considered a significant drawback,
        and so SPAKE2+ also appears in this document.</t>

    </section>
    <section title="IANA Considerations">
      <t>No IANA action is required.</t>
    </section>
    <section title="Acknowledgments">
      <t>Special thanks to Nathaniel McCallum and Greg Hudson
        for generation of test vectors.
        Thanks to Mike Hamburg for advice on how to deal with cofactors. Greg
        Hudson also suggested the addition of warnings on the reuse of x and y. Thanks
        to Fedor Brunner, Adam Langley, and the members of the CFRG for
        comments and advice. Trevor Perrin informed me of SPAKE2+.</t>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      <reference anchor="SEC1">
        <front>
          <title>STANDARDS FOR EFFICIENT CRYPTOGRAPHY, "SEC 1: Elliptic Curve
            Cryptography", version 2.0</title>
          <author>
            <organization>SEC</organization>
          </author>
          <date month="May" year="2009" />
        </front>
        <format type="PDF" target="http://www.sec.org/sec1-v2.pdf" />
      </reference>
      &RFC2104;
      &RFC2119;
      &RFC4493;
      &RFC5480;
      &RFC5869;
      &RFC6234;
      &RFC7748;
      &RFC8032;
      &RFC8174;
    </references>
    <references title="Informative References">
      <reference anchor="REF">
        <front>
          <title>Simple Password-Based Encrypted Key Exchange Protocols.</title>
          <author initials="M." surname="Abdalla" />
          <author initials="D." surname="Pointcheval" />
          <date month="Feb" year="2005" />
        </front>
        <annotation>Appears in A. Menezes, editor. Topics in
          Cryptography-CT-RSA 2005, Volume 3376 of Lecture Notes in Computer
          Science, pages 191-208, San Francisco, CA, US.  Springer-Verlag,
          Berlin, Germany.
        </annotation>
      </reference>
      <reference anchor="TDH">
        <front>
          <title>The Twin-Diffie Hellman Problem and Applications</title>
          <author initials="D." surname="Cash" />
          <author initials="E." surname="Kiltz" />
          <author initials="V." surname="Shoup" />
          <date year="2008" />
        </front>
        <annotation>EUROCRYPT 2008.  Volume 4965 of Lecture notes in Computer
          Science, pages 127-145.  Springer-Verlag, Berlin, Germany.
        </annotation>
      </reference>
      &RFC8265;
    </references>
  </back>
</rfc>
